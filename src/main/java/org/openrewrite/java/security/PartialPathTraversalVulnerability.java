/*
 * Copyright 2022 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.java.security;

import org.jetbrains.annotations.NotNull;
import org.openrewrite.*;
import org.openrewrite.internal.lang.Nullable;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.MethodMatcher;
import org.openrewrite.java.dataflow.LocalFlowSpec;
import org.openrewrite.java.dataflow.analysis.SinkFlow;
import org.openrewrite.java.search.UsesMethod;
import org.openrewrite.java.tree.Expression;
import org.openrewrite.java.tree.J;
import org.openrewrite.java.tree.JavaSourceFile;

import java.util.*;

public class PartialPathTraversalVulnerability extends Recipe {
    private static final MethodMatcher getCanonicalPathMatcher =
            new MethodMatcher("java.io.File getCanonicalPath()");
    private static final MethodMatcher startsWithMatcher =
            new MethodMatcher("java.lang.String startsWith(java.lang.String)");

    @Override
    public String getDisplayName() {
        return "Partial path traversal vulnerability";
    }

    @Override
    public String getDescription() {
        return "Replaces `dir.getCanonicalPath().startsWith(parent.getCanonicalPath()`, which is vulnerable to partial path traversal attacks, with the more secure `dir.getCanonicalFile().toPath().startsWith(parent.getCanonicalFile().toPath())`.\n\n" +
                "To demonstrate this vulnerability, consider `\"/usr/outnot\".startsWith(\"/usr/out\")`. The check is bypassed although `/outnot` is not under the `/out` directory. " +
                "It's important to understand that the terminating slash may be removed when using various `String` representations of the `File` object. " +
                "For example, on Linux, `println(new File(\"/var\"))` will print `/var`, but `println(new File(\"/var\", \"/\")` will print `/var/`; " +
                "however, `println(new File(\"/var\", \"/\").getCanonicalPath())` will print `/var`.";
    }

    @Override
    public Set<String> getTags() {
        return Collections.singleton("CWE-22");
    }

    @Override
    protected @Nullable TreeVisitor<?, ExecutionContext> getSingleSourceApplicableTest() {
        return new JavaVisitor<ExecutionContext>() {
            @Override
            public J visitJavaSourceFile(JavaSourceFile cu, ExecutionContext executionContext) {
                doAfterVisit(new UsesMethod<>(getCanonicalPathMatcher));
                doAfterVisit(new UsesMethod<>(startsWithMatcher));
                return cu;
            }
        };
    }

    @Override
    protected TreeVisitor<?, ExecutionContext> getVisitor() {
        return new PartialPathTraversalVulnerabilityVisitor<>();
    }

    private static class PartialPathTraversalVulnerabilityVisitor<P> extends JavaIsoVisitor<P> {
        private final JavaTemplate toPathGetCanonicalFileTemplate =
                JavaTemplate
                        .builder(this::getCursor, "#{any(java.io.File)}.getCanonicalFile().toPath()")
                        .build();
        private final JavaTemplate pathStartsWithPathTemplate =
                JavaTemplate
                        .builder(this::getCursor, "#{any(java.nio.file.Path)}.startsWith(#{any(java.nio.file.Path)})")
                        .build();

        private final JavaTemplate pathStartsWithStringTemplate =
                JavaTemplate
                        .builder(this::getCursor, "#{any(java.nio.file.Path)}.startsWith(#{any(String)})")
                        .build();

        private static final class GetCanonicalPathToStartsWithLocalFlow extends LocalFlowSpec<J.MethodInvocation, J.MethodInvocation> {
            @Override
            public boolean isSource(J.MethodInvocation source, Cursor cursor) {
                return getCanonicalPathMatcher.matches(source);
            }

            @Override
            public boolean isSink(J.MethodInvocation sink, Cursor cursor) {
                return startsWithMatcher.matches(sink) && sink.getSelect() instanceof J.Identifier;
            }
        }

        private static final class NotSafePartialPathTraversalLocalFlow extends LocalFlowSpec<Expression, Expression> {

            @Override
            public boolean isSource(Expression source, Cursor cursor) {
                return !isSafePartialPathExpression(source) && !(source instanceof J.Identifier);
            }

            @Override
            public boolean isSink(Expression sink, Cursor cursor) {
                J.MethodInvocation maybeStartsWith = cursor.firstEnclosing(J.MethodInvocation.class);
                if (maybeStartsWith != null) {
                    return startsWithMatcher.matches(maybeStartsWith) && maybeStartsWith.getArguments().contains(sink);
                }
                return false;
            }
        }

        @Override
        public Expression visitExpression(Expression expression, P p) {
            SinkFlow<Expression, Expression> sinks = dataflow().findSinks(new NotSafePartialPathTraversalLocalFlow());
            if (!sinks.isEmpty()) {
                getCursor().dropParentUntil(SourceFile.class::isInstance).putMessage("unsafeArgument", sinks.getSinks());
            }
            return super.visitExpression(expression, p);
        }

        @Override
        public J.MethodInvocation visitMethodInvocation(J.MethodInvocation method, P p) {
            Cursor parentCursor = getCursor().dropParentUntil(SourceFile.class::isInstance);
            if (getCanonicalPathMatcher.matches(method)) {
                // CASE: ...getCanonicalPath();
                SinkFlow<J.MethodInvocation, J.MethodInvocation> sinkFlow = dataflow().findSinks(new GetCanonicalPathToStartsWithLocalFlow());
                Map<Expression, Expression> replacement = parentCursor.getMessage("replacement", new HashMap<>());
                sinkFlow.getSinks().forEach(sink -> {
                    // MAP of:
                    // String k = VALUE /** VALUE **/.getCanonicalPath();
                    // k /** KEY **/.startsWith(...);
                    replacement.put(sink.getSelect(), sinkFlow.getSource().getSelect());
                });
                parentCursor.putMessage("replacement", replacement);
            } else if (startsWithMatcher.matches(method)) {
                assert method.getSelect() != null : "Select is null for `startsWith`";
                final Expression select = unwrap(method.getSelect());
                final Expression argument = unwrap(method.getArguments().get(0));
                List<Expression> unsafeArguments = parentCursor.getMessage("unsafeArgument");
                if (unsafeArguments == null) {
                    unsafeArguments = Collections.emptyList();
                }

                if (!isSafePartialPathExpression(argument)) {
                    if (getCanonicalPathMatcher.matches(select)) {
                        // CASE: getCanonicalPath().startsWith(...)
                        final J.MethodInvocation getCanonicalPathSelect = (J.MethodInvocation) select;
                        final J.MethodInvocation getCanonicalPathSelectReplacement =
                                replaceGetCanonicalPath(getCanonicalPathSelect);
                        return replaceWithPathStartsWithMethodInvocation(
                                method,
                                argument,
                                getCanonicalPathSelectReplacement
                        );
                    } else if (parentCursor.getMessage("replacement") != null) {
                        // CASE: canonicalPath.startsWith(...)
                        final Expression alternateSelect =
                                ((Map<Expression, Expression>) parentCursor.getMessage("replacement"))
                                        .get(select);
                        if (alternateSelect != null) {
                            J.MethodInvocation getCanonicalPathSelectReplacement = select.withTemplate(
                                    toPathGetCanonicalFileTemplate,
                                    ((J.Identifier) select).getCoordinates().replace(),
                                    alternateSelect
                            );
                            return replaceWithPathStartsWithMethodInvocation(
                                    method,
                                    argument,
                                    getCanonicalPathSelectReplacement
                            );
                        }
                    }
                }
            }
            return super.visitMethodInvocation(method, p);
        }

        private static boolean isSafePartialPathExpression(Expression expression) {
            if (expression instanceof J.Binary) {
                J.Binary concatArgument = (J.Binary) expression;
                if (J.Binary.Type.Addition.equals(concatArgument.getOperator())) {
                    // CASE: ...startsWith(... + ...);
                    Expression right = unwrap(concatArgument.getRight());
                    if (right instanceof J.FieldAccess) {
                        // CASE: ...startsWith(... + field);
                        return true;
                    } else if (right instanceof J.Literal) {
                        // CASE:
                        // - ...startsWith(... + "/);
                        // - ...startsWith(... + '/');
                        J.Literal literal = (J.Literal) right;
                        if (literal.getValue() instanceof String) {
                            String value = (String) literal.getValue();
                            // CASE: ...startsWith(... + "/");
                            return value.equals("/");
                        } else if (literal.getValue() instanceof Character) {
                            Character value = (Character) literal.getValue();
                            // CASE: ...startsWith(... + '/');
                            return value.equals('/');
                        }
                    }
                }
            }
            return false;
        }

        /**
         * Replaces the {@link String#startsWith(String)} call with a call to
         * {@link java.nio.file.Path#startsWith(java.nio.file.Path)} or
         * {@link java.nio.file.Path#startsWith(String)}.
         */
        @NotNull
        private J.MethodInvocation replaceWithPathStartsWithMethodInvocation(
                J.MethodInvocation method,
                Expression argument,
                J.MethodInvocation getCanonicalPathSubjectReplacement
        ) {
            if (getCanonicalPathMatcher.matches(argument)) {
                // CASE: ...startsWith(...getCanonicalPath())
                final J.MethodInvocation getCanonicalPathArgument = (J.MethodInvocation) argument;
                final J.MethodInvocation getCanonicalPathArgumentReplacement =
                        replaceGetCanonicalPath(getCanonicalPathArgument);
                return method
                        .withTemplate(
                                pathStartsWithPathTemplate,
                                method.getCoordinates().replace(),
                                getCanonicalPathSubjectReplacement,
                                getCanonicalPathArgumentReplacement
                        );
            } else {
                // CASE: ...startsWith(...)
                return method
                        .withTemplate(
                                pathStartsWithStringTemplate,
                                method.getCoordinates().replace(),
                                getCanonicalPathSubjectReplacement,
                                argument
                        );
            }
        }

        private static Expression unwrap(Expression expression) {
            if (expression instanceof J.Parentheses) {
                //noinspection unchecked
                return unwrap(((J.Parentheses<Expression>) expression).getTree());
            } else {
                return expression;
            }
        }

        private J.MethodInvocation replaceGetCanonicalPath(J.MethodInvocation getCanonicalPath) {
            return getCanonicalPath
                    .withTemplate(
                            toPathGetCanonicalFileTemplate,
                            getCanonicalPath.getCoordinates().replace(),
                            getCanonicalPath.getSelect()
                    );
        }
    }
}
